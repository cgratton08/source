@Service
public class ActiveSessionService
{
	private static final Logger logger = LoggerFactory.getLogger(ActiveSessionService.class);
		
	@Autowired
	public UserListRepository userSrvRep;

	
	protected static Map<String, ActiveSession> activeSessions = new ConcurrentHashMap<>();
	
	/**
	 * Register (User_List)user in memory for future reference.
	 * This is call by our AuthenticationHandler class
	 *
	 * If a User login while he(she) got already an ActiveSession in memory
	 * this new ActiveSession will replace the old one. 
	 * 
	 * If the session timeout reuse the session but reset the time registered 
	 * 
	 * NOTE. We do not need to implement a LogoutSuccessHandler since Spring Security
	 * handle HttpSession clean up through SecurityContextLogoutHandler which is call through our LdapSecurityConfiguration
	 * 
	 * @param user
	 */
	public void addActiveSession(UserList user) {	
		
		if (!activeSessions.containsKey(user.getUserId().toLowerCase())) {
			ActiveSession as = new ActiveSession(user, LocalDateTime.now());
			activeSessions.put(user.getUserId().toLowerCase(), as);
			logger.info("User {} logged in at {}, {}",user.getUserId(), as.getTimeRegistered(), as);
		} else {
			ActiveSession as = activeSessions.get(user.getUserId().toLowerCase());
			as.setTimeRegistered(LocalDateTime.now());
		}
	}
	
	public void deleteActiveSession(String uid) {
		if (activeSessions.remove(uid.toLowerCase()) != null)
			logger.info("Removing user {} from active sessions.", uid);
	}
	
	public ActiveSession getActiveSession(String uid) {
		return activeSessions.get(uid.toLowerCase());
	}

	public List<ActiveSession> getActiveSessions() {
		return activeSessions.values().stream().collect(Collectors.toList());		
	}
				
	/**
	 * Return the DB representation of the currently logged in (User_List)user
	 * from the HttpSession
	 * 
	 * @param uid
	 * @return UserList
	 */
	public UserList getLoggedUser()
	{
		String uid = getLoggedUserId();
		
		if (uid != null && activeSessions.containsKey(uid.toLowerCase())) 
			return activeSessions.get(uid.toLowerCase()).getUser();

		return null;
	}

	/**
	 * Return the full name of the currently logged in user
	 * 
	 * @return String The full name of the active user
	 */
	public String getActiveUserFullName()
	{
		UserList user = getLoggedUser();
		if (user != null)
			return user.getName();
		
		return "";
	}

	private String getLoggedUserId() {
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		if (auth != null)
			return auth.getName();
		
		return null;
	}

	/**
	 * Return if a user has a certain role
	 * 
	 * @param role
	 * @return
	 */
	public boolean isUserInRole(String role) 
	{		
		if (StringUtils.isEmpty(role))
			return false;
		
		UserList user = userSrvRep.findByUserIdIgnoringCase(getLoggedUserId());				
		return  user.getGroups().stream().anyMatch(g -> g.getName().equalsIgnoreCase(role));
	}
	
	/**
	 * Return if a user has a certain role
	 * 
	 * @param role
	 * @return
	 */
	public boolean isUserInRole(UserList user, String role) 
	{		
		if (StringUtils.isEmpty(role))
			return false;
							
		return  user.getGroups().stream().anyMatch(g -> g.getName().equalsIgnoreCase(role));
	}
	
	public boolean isActive(UserList user) {
		return Boolean.parseBoolean(user.getActive());
	}
}
